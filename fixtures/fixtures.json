[
    {
        "pk": null, 
        "model": "blog.BlogPost", 
        "fields": {
            "content": "[\r\n{\r\n    \"fields\": {\r\n        \"related_posts\": [\r\n            2\r\n        ],\r\n        \"short_url\": \"http://127.0.0.1:8000/blog/mezzanine-template-design/\",\r\n        \"site\": 1,\r\n        \"keywords_string\": \"mezzanine template design web\",\r\n        \"in_sitemap\": true,\r\n        \"featured_image\": \"uploads/splash/photo-1416431168657-a6c4184348ab.jpg\",\r\n        \"title\": \"Mezzanine Theme Design: Installing Mezzanine\",\r\n        \"use_dark_background\": false,\r\n        \"content\": \"<span class=\\\"dropcap\\\">A</span>s a newbie in the world of Mezzanine, I found many resources provided by the project to be tremendously useful. However, I remember a few obstacles I ran across while trying to get started that sometimes hindered my progress (often severely). I think this stems from the fact that I have no solid footing in any one aspect of web development. I am fairly confident in Python, but only with a solid eye on the documentation -- like many, I am completely self taught. This resulted in a largely non-linear education, causing numerous gaps in my learning that I had to fill as I went. This could be frustrating while also trying to simply get everything off the ground, and have at least *something*\\u00a0that **just worked.**  \\r\\n\\u00a0 \\u00a0 \\r\\n    As a result, I decided to create a series in which I describe more of the finer details that often get missed -- for people like me, with certain gaps in their learning that often make what should be a simple process much more difficult than it needs to be. Here's what the order of the series will look like:  \\r\\n\\r\\n1. Installing mezzanine and creating the proper development environment\\r\\n2. Setting up the development and production databases (and the difference between the two)\\r\\n3. Models and the layout of your average django app\\r\\n4. Useful Mezzanine utilities\\r\\n5. Creating your own theme: pages\\r\\n6. More to come...  \\r\\n\\r\\nLet's get started!\\r\\n\\r\\n------\\r\\n\\r\\n## Installing Mezzanine  \\r\\n\\r\\n\\r\\nPython is great. Here's one problem, however: when packages are installed, they're installed **globally**\\u00a0(as always, there are exceptions) which means that one package is used throughout the system. This is great for a lot of things, but it can cause some issues with development. Let's say you start a project, and install a certain amount of dependencies -- you build your entire project around those dependencies, and most importantly, that *version*\\u00a0of dependencies. Now, you start another project, and decide you want the shiny new feature of some previously installed dependency. You update the package, and suddenly your other project is completely broken. Crap! What do I do? A virtual environment is the answer.\\r\\n### virtualenv\\r\\n\\r\\nA virtual environment is exactly what it sounds like -- a sandbox, safe haven from the perils the open sea of globally installed packages entails. Well... maybe I got a bit \\\"overboard\\\". No, I will not apologize!\\r\\nBut anyway, it comes in handy sometimes.\\r\\n\\r\\n### Putting it all together\\r\\n\\r\\nOkay, here we go. Let's get a mezzanine project going. I assume you are using a linux system (or some other unix variant) and have pip installed.\\u00a0\\r\\n\\r\\nFirst, install virtualenv:\\r\\n\\r\\n    $ sudo apt-get install virtualenv\\r\\n\\r\\nNext, create a virtual environment:\\r\\n\\r\\n    $ virtualenv project_name\\r\\n\\r\\nIt will setup some things for you, like your own special pip instance for installing packages. Next:\\r\\n\\r\\n    $ cd project_name\\u00a0 \\r\\n    $ source bin/activate\\r\\n\\r\\nThe\\u00a0`source bin/activate` command is **super important.** This is what starts the insulated environment, and installs packages locally (not globally) so your project's libraries are safe. Every time you start working on your app, you should run this command -- believe me, it's the kind of mistake you only want to make once. You can check by looking at the left of the command line: if your virtualenv name is there in parentheses, you're good. Now we're ready to start the project.\\r\\n\\r\\nInstall mezzanine:\\r\\n\\r\\n    $ pip install south mezzanine\\r\\n    $ mezzanine-project project_name\\r\\n    $ mv project_name/* .\\r\\n\\r\\nThat last command moves the mezzanine project into the main directory, since a mezzanine project needs a name and cannot be generated with a `.` (eg, in that directory) -- and you don't want to end up with a bunch of nested directories to get through. Now the previous directory is empty, so you can remove it.\\r\\n\\r\\n    $ rm -r project_name\\r\\n\\r\\nWe can now create the server by:\\r\\n\\r\\n    $ python manage.py createdb\\r\\n\\r\\nIf you just want the default settings and/or no demo data, you can run\\r\\n\\r\\n    $ python manage.py createdb --noinput --nodata\\r\\n\\r\\ninstead.\\r\\n\\r\\nNow that the database is created, you can start the server:\\r\\n\\r\\n    $ python manage.py runserver\\r\\n\\r\\nand go check it out at localhost, port 8000: `127.0.0.1:8000`\\r\\n\\r\\n\",\r\n        \"rating_sum\": 0,\r\n        \"rating_count\": 0,\r\n        \"categories\": [\r\n            1\r\n        ],\r\n        \"publish_date\": \"2015-01-01T04:42:38Z\",\r\n        \"status\": 2,\r\n        \"updated\": \"2015-01-04T06:31:36.805Z\",\r\n        \"description\": \"As a newbie in the world of Mezzanine, I found many resources provided by the project to be tremendously useful. However, I remember a few obstacles I ran across while trying to get started that sometimes hindered my progress (often severely)\",\r\n        \"rating_average\": 0.0,\r\n        \"expiry_date\": null,\r\n        \"user\": 1,\r\n        \"slug\": \"mezzanine-template-design\",\r\n        \"gen_description\": false,\r\n        \"allow_comments\": true,\r\n        \"created\": \"2015-01-01T04:43:09.633Z\",\r\n        \"_meta_title\": \"\",\r\n        \"comments_count\": 0\r\n    },\r\n    \"model\": \"blog.blogpost\",\r\n    \"pk\": 1\r\n},\r\n{\r\n    \"fields\": {\r\n        \"related_posts\": [\r\n            1\r\n        ],\r\n        \"short_url\": \"http://127.0.0.1:8000/blog/mezzanine-template-design-the-database/\",\r\n        \"site\": 1,\r\n        \"keywords_string\": \"mezzanine template design web postgresql python django\",\r\n        \"in_sitemap\": true,\r\n        \"featured_image\": \"uploads/splash/6e609595.jpg\",\r\n        \"title\": \"Mezzanine Theme Design: The Database\",\r\n        \"use_dark_background\": true,\r\n        \"content\": \"This is the second part of a Template Design Series. If you haven't installed mezzanine yet, and/or don't have a working project, you might want to start with [Part 1.][1]\\n\\n## Mezzanine: The Database\\n\\n### But I postgres...\\n\\nSo right now all of your data is stored in a file, called `dev.db`, in your home directory. This is great for development, cause it's right there, you can destroy it and start over if you have to quite easily, and it doesn't involve much setup. \\n          \\nBut it's not a great solution for production. For that, I use postgres. If you're interested in setting it up, follow along, if not, you can skip ahead -- **do not do this section if this is your first time reading the article. This database is best used in production, *not development.* **  \\n\\nFirst, install postgres: \\n\\n    $ sudo apt-get install postgresql postgresql-client\\n\\nNext, install psycopg2:\\n  \\n    $ pip install psycopg2\\n\\nAnd change some settings in `local_settings.py`:\\n\\n    :::python\\n    # local_settings.py\\n\\n    DATABASES = {\\n        \\\"default\\\": {\\n            # Add \\\"postgresql_psycopg2\\\", \\\"mysql\\\", \\\"sqlite3\\\" or \\\"oracle\\\".\\n            \\\"ENGINE\\\": \\\"django.db.backends.postgresql_psycopg2\\\",\\n            # DB name or path to database file if using sqlite3.\\n            \\\"NAME\\\": \\\"project_db\\\",\\n            # Not used with sqlite3.\\n            \\\"USER\\\": \\\"project_user\\\",\\n            # Not used with sqlite3.\\n            \\\"PASSWORD\\\": \\\"project_pass\\\",\\n            # Set to empty string for localhost. Not used with sqlite3.\\n            \\\"HOST\\\": \\\"localhost\\\",\\n            # Set to empty string for default. Not used with sqlite3.\\n            \\\"PORT\\\": \\\"\\\",\\n        }\\n    }\\n\\nYou can leave the settings in `settings.py` alone for now.\\n\\nNow, we have to create the database. First:\\n\\n    $ sudo -u postgres psql postgres\\n\\nThis starts a postgres prompt, as user postgres (i.e the \\\"`-u`\\\" switch). It's basically saying, \\\"execute this command, as sudo of the user postgres, to run the command `psql` with argument `postgres`.\\\" You should get a prompt that looks like this:\\n\\n    postgres=#\\n\\nNow let's create a database that fits the credentials we used in `local_settings.py`. First (note when the semi-colon is used, and when it isn't):\\n\\n    postgres=# create database project_db;\\n    postgres=# create user project_user;\\n    postgres=# \\\\password project_user\\n\\nWe're all done with postgres for now, so we can do:\\n\\n    postgres=# \\\\q\\n\\nto exit. Now since we're using a different database, we can get rid of the sqlite one:\\n\\n    $ rm dev.db\\n\\nAnd re-run the `createdb` command to regenerate the database. \\n\\n    $ python manage.py createdb --noinput --nodata\\n\\nAll done.\\n\\n-------\\n\\n  [1]: http://averylaird.com/blog/mezzanine-template-design/\",\r\n        \"rating_sum\": 0,\r\n        \"rating_count\": 0,\r\n        \"categories\": [\r\n            1\r\n        ],\r\n        \"publish_date\": \"2015-01-01T18:47:45Z\",\r\n        \"status\": 2,\r\n        \"updated\": \"2015-01-07T19:24:06.058Z\",\r\n        \"description\": \"This is the second part of a Template Design Series. If you haven't installed mezzanine yet, and/or don't have a working project, you might want to start with Part 1.\",\r\n        \"rating_average\": 0.0,\r\n        \"expiry_date\": null,\r\n        \"user\": 1,\r\n        \"slug\": \"mezzanine-template-design-the-database\",\r\n        \"gen_description\": true,\r\n        \"allow_comments\": true,\r\n        \"created\": \"2015-01-01T18:49:53.497Z\",\r\n        \"_meta_title\": \"\",\r\n        \"comments_count\": 0\r\n    },\r\n    \"model\": \"blog.blogpost\",\r\n    \"pk\": 2\r\n},\r\n{\r\n    \"fields\": {\r\n        \"related_posts\": [],\r\n        \"short_url\": \"http://averylaird.com/blog/mezzanine-template-design-the-django-app-models/\",\r\n        \"site\": 1,\r\n        \"keywords_string\": \"\",\r\n        \"in_sitemap\": true,\r\n        \"featured_image\": \"uploads/blog/photo-1415201179613-bd037ff5eb29.jpg\",\r\n        \"title\": \"Mezzanine Template Design: The Django App + Templates\",\r\n        \"use_dark_background\": true,\r\n        \"content\": \"## The Django App\\r\\n\\r\\n<span class=\\\"dropcap\\\">T</span>he main principle behind theme design in mezzanine involves a django app, placed in your project, that handles all of the custom styling and templates you want in the project. This way, one can share themes, install someone else's theme, or migrate/update their project quite easily. It keeps things modular, the benefits of which are explained (ad nauseam, believe me) [here][1]. By default, a django app consists of models and views. There are also files for tests, migrations (later explained with databases) and handling the admin side of things. Let's start by creating our `theme` app. This is pretty easy to do:\\r\\n\\r\\n    $ python django-admin.py startapp theme\\r\\n\\r\\nYou'll see a new directory, called `theme`, show up in your project. The file tree should look something like this:\\r\\n\\r\\n    theme/\\r\\n        __init__.py\\r\\n        admin.py\\r\\n        migrations/\\r\\n            __init__.py\\r\\n        models.py\\r\\n        tests.py\\r\\n        views.py\\r\\n\\r\\nI'll do a quick overview of each thing:\\r\\n\\r\\n1. `__init__.py` should be in the directory every time it's something you want python to find -- that is largely what it does, in fact the file itself is often empty. It has other important uses as well, but that's all I'll say about it for now.\\r\\n2. `admin.py` is used in the context of the admin site. This is where you register your app and tell django how to handle/display it.\\r\\n3. `migrations/` directory: contains the migrations for that app. Migrations are used with the database and south -- we'll get more in depth about this later.\\r\\n4. `models.py` is where the magic happens, or at least a large majority of it. This is where we represent models using classes (which subclass django's own special spice) and fields using class variables. We define how and when data should be stored. If you're new to this, it will probably make more sense once you see models in use.\\r\\n5. `tests.py` is a file every good programmer *should* use with all their apps. I guess I'm not a good programmer...\\r\\n6. `views.py` is not something we'll be using in the context of creating our theme. \\r\\n\\r\\nOkay, now that we've got all that explained, we can get started actually creating a theme! I'm going to start with a free theme called [clean blog][2] (actually what I used when first creating this site) and convert it to a new-and-improved mezzanine powered blog. \\r\\n\\r\\n### Install the app\\r\\n\\r\\nWe'll be making changes to our app and the data it deals with over the course of the series, but we can install it now. First, you have to add it to your `INSTALLED_APPS` setting in `settings.py`:\\r\\n\\r\\n    :::python\\r\\n    # settings.py\\r\\n\\r\\n    INSTALLED_APPS = (\\r\\n    \\t\\\"theme\\\",\\r\\n        \\\"django.contrib.admin\\\",\\r\\n    \\t\\\"django.contrib.auth\\\",\\r\\n        \\\"django.contrib.contenttypes\\\",\\r\\n        \\\"django.contrib.redirects\\\",\\r\\n    \\t\\\"django.contrib.sessions\\\",\\r\\n    \\t\\\"django.contrib.sites\\\",\\r\\n    \\t\\\"django.contrib.sitemaps\\\",\\r\\n    \\t\\\"django.contrib.staticfiles\\\",\\r\\n    \\t\\\"mezzanine.boot\\\",\\r\\n    \\t\\\"mezzanine.conf\\\",\\r\\n    \\t\\\"mezzanine.core\\\",\\r\\n    \\t\\\"mezzanine.generic\\\",\\r\\n    \\t\\\"mezzanine.blog\\\",\\r\\n    \\t\\\"mezzanine.forms\\\",\\r\\n    \\t\\\"mezzanine.pages\\\",\\r\\n    \\t\\\"mezzanine.galleries\\\",\\r\\n    \\t\\\"mezzanine.twitter\\\",\\r\\n    \\t#\\\"mezzanine.accounts\\\",\\r\\n    \\t#\\\"mezzanine.mobile\\\",\\r\\n    )\\r\\n\\r\\nMake sure you add it first, so it's templates override mezzanine's, and remember the comma after the quotes. Our app doesn't have any models yet, so there's no need to migrate or sync the database (although it may be a good idea, just to check and see if you missed anything)\\r\\n\\r\\n## Collect Templates\\r\\n\\r\\nRight now, the website we see at localhost has it's templates being served from mezzanine, in `lib/python2.x/site-packages/mezzanine/core/templates/`. We don't want to get rid of them, or change them directly, but we don't have to -- they can be overridden. We will set up our app so that its templates are loaded before mezzanine's. This makes everything less messy, mostly because we can update mezzanine without causing a lot of issues, and we can move our `theme` app around and use it somewhere else.\\r\\n    If we where to collect all of the templates, that would be too much; there are some that we don't want. With that in mind, let's collect each template as we need to, starting with `base.html`:\\r\\n\\r\\n    $ python manage.py collecttemplates -t base.html\\r\\n\\r\\nThe template has been copied into a newly created directory, `templates/`, in your project directory. We want it in our app though, so let's copy the whole `templates/` directory over:\\r\\n\\r\\n    $ mv templates theme\\r\\n\\r\\nNow, our app's `base.html` will take precendence over the default. You can test this out by making changes to `theme/templates/base.html` and seeing them reflect in the site.\\r\\n\\r\\n## Homepage Elements\\r\\n\\r\\n> If you'd like to follow along with the tutorial using the clean blog template, you should download it into your project directory. Depending on \\r\\n> your preferences, you can either directly download it from the site or clone it using git. My preference is to just go:\\r\\n> \\r\\n>     $ git clone git@github.com:IronSummitMedia/startbootstrap-clean-blog.git\\r\\n> \\r\\n> in the project directory.\\r\\n\\r\\n\\r\\nOur ``index.html`` is going to be the template that we draw the elements from our site from, so let's take a look at what we need to migrate over to our new shiny mezzanine app. Going from top to bottom, I see a:\\r\\n\\r\\n* navbar\\r\\n* splash image \\r\\n* header/subheader\\r\\n* List of recent blog posts, with:\\r\\n    * header\\r\\n    * description/subheader\\r\\n    * Metadata (author, day posted)\\r\\n    * horizontal rule\\r\\n    * pagination\\r\\n* footer\\r\\n    * social media buttons\\r\\n        * twitter\\r\\n        * facebook\\r\\n        * github\\r\\n    * info text (copyright, name)\\r\\n\\r\\nLet's start by making some changes to `base.html`.\\r\\n\\r\\n### Prepping base.html    \\r\\n   \\r\\n1.    Right now, `base.html` is the default mezzanine template, but we want our own fancy one, so let's get rid of what we don't want by deleting everything inside the `<body>` tag until the `{% include \\\"includes/footer_scripts.html\\\" %}` tag. \\r\\n2.    Transfer everything inside the header of the blog's `index.html` to the header of `base.html` -- all of the javascript and css. \\r\\n4.    Move everything inside the `<body>` tags of the clean blog's `index.html` to the `<body>` tags of `base.html`\\r\\n\\r\\nYou're almost done this step: the last thing you have to do is update the locations of the static content for the blog. When we moved the links in the header over, the respective paths changed, so we now have to move the content into the app and update the references in `base.html` to match.\\r\\n\\r\\n1.    Create a `static` directory in `theme`:  \\r\\n\\r\\n        $ mkdir theme/static\\r\\n\\r\\n2.    Transfer over the static files:  \\r\\n\\r\\n        $ mv startbootstrap-clean-blog/css/ theme/static/ \\r\\n        $ mv startbootstrap-clean-blog/js/ theme/static/\\r\\n        $ mv startbootstrap-clean-blog/img/ theme/static/\\r\\n\\r\\n3.    Update references. For example:    \\r\\n\\r\\n        :::html\\r\\n        <!-- index.html -->\\r\\n\\r\\n        <link href=\\\"css/clean-blog.min.css\\\" rel=\\\"stylesheet\\\">\\r\\n\\r\\n      Becomes:  \\r\\n  \\r\\n        :::html+django\\r\\n        <!-- base.html -->\\r\\n  \\r\\n        <link href=\\\"{% static \\\"css/clean-blog.min.css\\\" %}\\\" rel=\\\"stylesheet\\\">\\r\\n\\r\\n> The body of `index.html` also includes some images and other links: **don't forget to update those references too!** That would look like this:\\r\\n>    :::html+django\\r\\n>    <header class=\\\"intro-header\\\" style=\\\"background-image: url(\\\"{% static \\\"img/home-bg.jpg\\\" %}\\\")\\\">\\r\\n> \\r\\n\\r\\nNeat! Quick side-note: If you're using a halfway decent editor like vim or emacs and/or some sort of IDE, I would recommend using a search and replace tool to update your references.  \\r\\n\\r\\nAt this point, if you run the server, you'll see (should see) the new template rendered. Take this time to make sure everything's loading properly, and that all of the css and javascript is being found. If an element/style is not loading correctly, take a look at the server's output in the shell or your browser's dev tools (if it has any) to find the problem. I usually miss one or two files first time 'round, so this is a good spot to check your work.\\r\\n\\r\\n### Navbar\\r\\n\\r\\nIf you take a look at the `index.html` you'll notice the navbar is layed out like a standard boostrap navbar:\\r\\n\\r\\n    :::html\\r\\n    <nav class=\\\"navbar navbar-default navbar-custom navbar-fixed-top\\\">\\r\\n      <div class=\\\"container-fluid\\\">\\r\\n        <!-- Brand and toggle get grouped for better mobile display -->\\r\\n         <div class=\\\"navbar-header page-scroll\\\">\\r\\n           <button type=\\\"button\\\" class=\\\"navbar-toggle\\\" data-toggle=\\\"collapse\\\" data-target=\\\"#bs-example-navbar-collapse-1\\\">\\r\\n                    <span class=\\\"sr-only\\\">Toggle navigation</span>\\r\\n                    <span class=\\\"icon-bar\\\"></span>\\r\\n                    <span class=\\\"icon-bar\\\"></span>\\r\\n                    <span class=\\\"icon-bar\\\"></span>\\r\\n                </button>\\r\\n                <a class=\\\"navbar-brand\\\" href=\\\"index.html\\\">Start Bootstrap</a>\\r\\n            </div>\\r\\n\\r\\n            <!-- Collect the nav links, forms, and other content for toggling -->\\r\\n            <div class=\\\"collapse navbar-collapse\\\" id=\\\"bs-example-navbar-collapse-1\\\">\\r\\n                <ul class=\\\"nav navbar-nav navbar-right\\\">\\r\\n                    <li>\\r\\n                        <a href=\\\"index.html\\\">Home</a>\\r\\n                    </li>\\r\\n                    <li>\\r\\n                        <a href=\\\"about.html\\\">About</a>\\r\\n                    </li>\\r\\n                    <li>\\r\\n                        <a href=\\\"post.html\\\">Sample Post</a>\\r\\n                    </li>\\r\\n                    <li>\\r\\n                        <a href=\\\"contact.html\\\">Contact</a>\\r\\n                    </li>\\r\\n                </ul>\\r\\n            </div>\\r\\n            <!-- /.navbar-collapse -->\\r\\n        </div>\\r\\n        <!-- /.container -->\\r\\n    </nav>\\r\\n\\r\\nThe navbar is something we want on every page of our site (usually), as well has the header and footer -- that means we should probably put them in our `base.html`. You can go ahead delete everything in the `base.html` right now, from the `body` tag to `{% include \\\"includes/footer_scripts.html\\\" %}`. \\r\\n\\r\\n  [1]: https://docs.djangoproject.com/en/1.7/intro/reusable-apps/\\r\\n  [2]: http://startbootstrap.com/template-overviews/clean-blog/\",\r\n        \"rating_sum\": 0,\r\n        \"rating_count\": 0,\r\n        \"categories\": [\r\n            1\r\n        ],\r\n        \"publish_date\": \"2015-01-08T05:16:22Z\",\r\n        \"status\": 1,\r\n        \"updated\": \"2015-01-09T03:54:07.602Z\",\r\n        \"description\": \"The main principle behind theme design in mezzanine involves a django app, placed in your project, that handles all of the custom styling and templates you want in the project. This way, one can share themes, install someone else's theme, or migrate/update their project quite easily.\",\r\n        \"rating_average\": 0.0,\r\n        \"expiry_date\": null,\r\n        \"user\": 1,\r\n        \"slug\": \"mezzanine-template-design-the-django-app-models\",\r\n        \"gen_description\": false,\r\n        \"allow_comments\": true,\r\n        \"created\": \"2015-01-03T00:37:12.820Z\",\r\n        \"_meta_title\": \"\",\r\n        \"comments_count\": 0\r\n    },\r\n    \"model\": \"blog.blogpost\",\r\n    \"pk\": 3\r\n},\r\n{\r\n    \"fields\": {\r\n        \"related_posts\": [\r\n            7\r\n        ],\r\n        \"short_url\": \"http://averylaird.com/blog/proving-the-first-fundamental-theorem-of-calculus-with-python/\",\r\n        \"site\": 1,\r\n        \"keywords_string\": \"\",\r\n        \"in_sitemap\": true,\r\n        \"featured_image\": \"uploads/blog/photo-1418065460487-3e41a6c84dc5.jpg\",\r\n        \"title\": \"Proving the First Fundamental Theorem of Calculus With Python\",\r\n        \"use_dark_background\": true,\r\n        \"content\": \"###Explaining the Theorem\\r\\n\\r\\nThe first fundamental theorem of calculus sounds scary -- but really, it's very simple on the surface. It says that if we have a function, $F(x)$, which defines the area between some other function, $f(t)$ (note the case change between the two), $F'(x)$ is equal to $f(x)$. Note that now, $f(t)$ is with respect to $x$ instead of $t$. We can write this in a more concise form:\\r\\n \\r\\n$$F(x) = \\\\int\\\\limits_a^x f(t) dt $$\\r\\n$$F'(x) = f(x)$$\\r\\n\\r\\nWe also know that:\\r\\n\\r\\n$$F(x) = \\\\lim_{n \\\\to \\\\infty} \\\\sum_{k=1}^{n} f(x_k *)\\\\Delta x$$\\r\\n\\r\\nYou'll want to keep that last equation in your back pocket, because it really comes into play later. For now, let's try to apply this idea in terms of python, to illustrate its meaning. First, let's say we want to find the area under $y = x^2$:\\r\\n\\r\\n    ::python\\r\\n    def f(t): return t**2\\r\\n\\r\\nCalling this function over a given interval would return each integer, but squared. For example:\\r\\n\\r\\n    ::python\\r\\n    >>> f(1)\\r\\n    1\\r\\n    >>> f(2)\\r\\n    4\\r\\n    >>> for t in range(0, 4):\\r\\n    ...    f(t)\\r\\n    0\\r\\n    1\\r\\n    4\\r\\n    9\\r\\n\\r\\nNow, we *could* find the area without integrating, using Riemann sums.\\r\\n\\r\\n####What is a Riemann Sum? \\r\\n\\r\\nIn principle, a Riemann sum is very simple. It says that we can approximate the area under the curve using rectangles. Here's an animation to illustrate the concept:\\r\\n\\r\\n![Riemann sum for y=x^2][1]     \\r\\n\\r\\nFirst, we create a series of terms to describe the total area of $n$ amount of rectangles, and observe that quantity as $n$ approaches $\\\\infty$. Let's try approximating the area using 4 rectangles first:\\r\\n\\r\\n    ::python\\r\\n    >>> delta_x = (3-1)/4\\r\\n    >>> (delta_x * 1.5**2) + (0.5 * 2**2) + (0.5 * 2.5**2) + (0.5 * 3**2)\\r\\n    10.75\\r\\n\\r\\nSo according to this result, an approximation of the area under $y=x^2$ in the interval $[1, 3]$ is 10.75. Our method could be improved and refactored. Using the previous value of `delta_x`, we can change our code to the following:\\r\\n\\r\\n    ::python\\r\\n    area = 0\\r\\n    for n in range(3, 7):\\r\\n        area += float(delta_x) * f(delta_x*n)\\r\\n    print(area)\\r\\n\\r\\nThis could be done in many different ways: for example, I chose to make the starting value of `range()` 3, so I would get the needed initial value of $\\\\frac{3}{4}$, but you could accomplish the same result using any number of methods.\\r\\n\\r\\n###Exact value\\r\\n\\r\\nBy this point, if you've looked up the area (or already know it) the *actual* area is more like $\\\\frac{26}{3}$, or $8.\\\\bar{6}$. That seems pretty far off from 10.75. How can we improve our approximation? Normally, you'd do that by taking the limit of our area function as *n* rectangles approaches infinity, which is what the equation at the beginning of this article describes. For us, using python, we can't actually **go** to infinity -- but let's see how close we can get by changing our code a bit more. \\r\\n\\r\\n1. One of our terms, `delta_x`, depends on the number of rectangles\\r\\n2. We'll need to change our `range()` to iterate $n$ times\\r\\n\\r\\nFirst, let's see how changing 4 rectangles to 50 rectangles changes our terms.\\r\\n\\r\\n    ::python\\r\\n    >>> delta_x = (3-1)/50\\r\\n    >>> (delta_x * 1.04**2) + (delta_x * 1.08**2) + (delta_x * 1.12**2) + ...\\r\\n\\r\\nTo incorporate this into our `for` loop, we need to take the number of rectangles into account:\\r\\n\\r\\n    ::python\\r\\n    delta_x = float((3-1)/50)\\r\\n    area = 0\\r\\n    for n in range(1, 51):\\r\\n        area += float(delta_x) * f(delta_x*n + 1) \\r\\n    print(area)\\r\\n\\r\\nWhen we run, we should get 8.8272. Closer! What about 1000 rectangles?\\r\\n\\r\\n    ::python\\r\\n    delta_x = float((3-1)/1000)\\r\\n    area = 0\\r\\n    for n in range(1, 1001):\\r\\n        area += float(delta_x) * f(delta_x*n + 1)\\r\\n    print(area)\\r\\n\\r\\n8.674668. Not bad. Now, with that last example, you may have noticed something exciting: in order to change the number of rectangles, we only have to change two values (which are related mathematically). This means we can make a function to approximate the area under $y=x^2$ from $[1,3]$ for *any* number of rectangles:\\r\\n\\r\\n    ::python\\r\\n    def F(x):\\r\\n        delta_x = float((3-1)/x)\\r\\n        area = 0\\r\\n        for n in range(1, x+1):\\r\\n            area += float(delta_x) * f(delta_x*n + 1)\\r\\n        return area \\r\\n\\r\\n    >>> F(4)\\r\\n    10.75\\r\\n    >>> F(50)\\r\\n    8.8272\\r\\n    >>> F(1000)\\r\\n    8.674668\\r\\n\\r\\nNotice the case change for `F(x)`? Now we have a function for approximating the area under the curve of $y=x^2$, for as many rectangles as we'd like. How far can we take our code?\\r\\n\\r\\n    ::python\\r\\n    >>> F(10000)\\r\\n    8.66746668\\r\\n    >>> F(100000)\\r\\n    8.6667466668\\r\\n    >>> F(1000000)\\r\\n    8.66667466667\\r\\n\\r\\nAs you'll notice, the value *as we approach* (eg, the limit) a large number of rectangles is $8.66\\\\bar{6}$. Interesting; with one million rectangles, we confirmed the area under the curve (on that interval) to 4 decimal places.\\r\\n\\r\\n###The proof\\r\\n\\r\\nAt this point, our code is functional. However, If you were reading carefully -- or have a knowledge of calculus -- you may have noticed an error in logic that needs to be corrected before we can move forward. `F(x)` takes one parameter which determines the number of rectangles to be used when approximating the area. However, `x` is actually the **second limit of integration, relative to $a$ **. I want to retain the ability to dynamically define the number of rectangles used, but the use of `x` is still misleading and needs to be fixed. To remedy the situation, I will add another parameter, which serves the proper purpose:\\r\\n\\r\\n    ::python\\r\\n    def F(x, rectangles=1000):\\r\\n        delta_x = float((x-1)/rectangles)\\r\\n        area = 0\\r\\n        for n in range(1, rectangles+1):\\r\\n            area += float(delta_x) * f(delta_x*n + 1)\\r\\n        return area\\r\\n\\r\\n    >>> F(3)\\r\\n    8.674667999999999\\r\\n \\r\\nI have given `rectangles` a default value of 1000, which seems to be a decent approximation, so that my calls to `F(x)` are more clear. If need be, I can increase the value of `rectangles` to gain a greater degree of accuracy.\\r\\n\\r\\n> As an interesting side note, try finding the area on $[-1, 1]$:\\r\\n>  \\r\\n    ::python\\r\\n    >>> F(-1)\\r\\n    -0.6666679999999993\\r\\n    >>> F(-1, 1000000000)\\r\\n    -0.6666666666653588\\r\\n\\r\\n> Since we are moving from 1 *backwards* to -1, the area is negative. If you were to actually mathematically compute this area, it would be $-\\\\frac{2}{3}$, or $-0.6\\\\bar{6}$. Our code works!\\r\\n\\r\\nAt this point, we're ready to prove the statement I made at the beginning: that $F'(x) = f(x)$. We have `F(x)`, and we have `f(x)`. It is also known that $f(t) = t^2$, which in terms of $x$ would mean that $f(x) = x^2$. So, what we are really trying to prove, in relation to the code we've created, is as follows: if we were to graph the slope of `F(x)` over $[a, b]$, the graph would perfectly match `f(x)` over the same interval. In order to graph the slope of `F(x)`, we need to take the derivative, and for that we need **the definition of a derivative** (in terms of our area function):\\r\\n\\r\\n$$\\r\\nF'(x) = \\\\lim_{h \\\\to 0}\\\\frac{F(x+h) - F(x)}{h}\\r\\n$$\\r\\n\\r\\nJust like the Riemann sums, this is an approximation, since $F'(x)$ would be undefined if $h=0$. The closer $h$ is to 0, the more accurate the result. This is a really lucky situation, because translating the math to code really just involves copying it almost symbol for symbol:\\r\\n\\r\\n    ::python\\r\\n    def derivative(f, h=0.1e-5):\\r\\n        def df(x, h)\\r\\n            return (f(x+h/2) - f(x-h/2))/h\\r\\n        return df\\r\\n    >>> d = derivative(f)\\r\\n    >>> d(2)\\r\\n    4.00000000012\\r\\n\\r\\nThis makes sense, because $\\\\frac{d}{dx}[x^2] = 2x$. And, $2 \\\\cdot 2 = 4$. I also divided $h$ by 2, to get a better approximation (thanks to advice from [this][2] article). Let's see what happens when we use this new `derivative()` function on `F(x)`:\\r\\n\\r\\n    ::python\\r\\n    >>> d = derivative(F)\\r\\n    >>> d(2)\\r\\n    4.003500499560886\\r\\n    >>> f(2)\\r\\n    4\\r\\n\\r\\nJust to remind you, let's review what equals what:\\r\\n\\r\\n`f(x)` = $f(x)$\\r\\n    \\r\\n`F(x)` = $F(x)$\\r\\n    \\r\\n`d` = $F'(x)$\\r\\n    \\r\\n$F'(x) = f(x)$\\r\\n    \\r\\nSo in terms of our code, we want `d` to equal `f(x)`. From our test run above, that has been confirmed to 2 decimal places. Don't believe me? Let's try some more values:\\r\\n\\r\\n    ::python\\r\\n    >>> d(3)\\r\\n    9.010001999598671\\r\\n    >>> f(3)\\r\\n    9\\r\\n    >>> d(4)\\r\\n    16.01950448559819\\r\\n    >>> f(4)\\r\\n    16\\r\\n\\r\\nMaybe that's *still* not enough to convince me. How about we compute these value over a range, and compute the percent deviation between them:\\r\\n\\r\\n    ::python\\r\\n    y = {d(n): f(n) for n in range(0, 100)} #create values\\r\\n    diff = []\\r\\n    for y1, y2 in y.iteritems():\\r\\n        '''\\r\\n        Calculate the percent difference between each pair of values\\r\\n        '''\\r\\n        diff.append(abs((y2 - y1)/((y2 + y1)/2)) * 100)\\r\\n    percentSum = 0\\r\\n    for percent in diff:\\r\\n        percentSum += percent\\r\\n    print(percentSum/len(diff))\\r\\n\\r\\n    2.14244620353\\r\\n\\r\\nSo an approximation (definition of a derivative) of an approximation (Riemann sum) has proven the first fundamental theorem of calculus to within 2%. For individual numbers, that difference seems even smaller -- for example, the percent difference between `d(1)` and `f(1)` is 2.8839...e-09 percent, or about $2.9 \\\\cdot 10^{-9}$ percent. Obviously, with a larger test sample this number will continue to decrease.\\r\\n\\r\\n###Conclusion and Extension\\r\\n\\r\\nSo there you have it -- the first fundamental theorem of calculus would appear to be true. You could go even further by using a larger sample size and a greater number of rectangles; graphing `d` and `f(x)` would yield the exact same line. I lack the computing power and the time to generate the data, but this could be a cool exercise for the reader (and easy to do with matplotlib or some other python graphing library). Additionally, computing the derivative with an even smaller value of $h$ would improve your results further. If you find any errors or misconceptions in the article, or have any suggestions for improvement, please send me an email at laird.avery@gmail.com or leave a comment below. \\r\\n \\r\\n  [1]: /static/media/uploads/riemann_sum_%28y=x%5E2%29.gif\\r\\n  [2]: http://aroberge.blogspot.ca/2005/04/computing-derivatives-using-python.html\",\r\n        \"rating_sum\": 0,\r\n        \"rating_count\": 0,\r\n        \"categories\": [],\r\n        \"publish_date\": \"2015-02-21T03:49:44Z\",\r\n        \"status\": 2,\r\n        \"updated\": \"2015-02-25T00:19:51.825Z\",\r\n        \"description\": \"Explaining the Theorem\\nThe first fundamental theorem of calculus sounds scary -- but really, it's very simple on the surface. It says that if we have a function, $F(x)$, which defines the area between some other function, $f(t)$ (note the case change between the two), $F'(x)$ is equal to $f(x)$. Note that now, $f(t)$ is with respect to $x$ instead of $t$. We can write this in a more concise form:\",\r\n        \"rating_average\": 0.0,\r\n        \"expiry_date\": null,\r\n        \"user\": 1,\r\n        \"slug\": \"proving-the-first-fundamental-theorem-of-calculus-with-python\",\r\n        \"gen_description\": true,\r\n        \"allow_comments\": true,\r\n        \"created\": \"2015-02-21T03:58:42.051Z\",\r\n        \"_meta_title\": \"\",\r\n        \"comments_count\": 0\r\n    },\r\n    \"model\": \"blog.blogpost\",\r\n    \"pk\": 4\r\n},\r\n{\r\n    \"fields\": {\r\n        \"related_posts\": [],\r\n        \"short_url\": \"http://averylaird.com/blog/area-under-a-curve-in-three-dimensions/\",\r\n        \"site\": 1,\r\n        \"keywords_string\": \"\",\r\n        \"in_sitemap\": true,\r\n        \"featured_image\": \"\",\r\n        \"title\": \"Area Under a Curve in Three Dimensions\",\r\n        \"use_dark_background\": false,\r\n        \"content\": \"### Area Under A Curve\\r\\n\\r\\nI recently wrote an article about finding the area under $y=x^2$. I had a lot of interesting insights from that project, and it got me thinking about some other things we could do with the code. If you haven't read the article, you can get it [here][1]. I was thinking about ways to improve my code and expand its use, so that it could be used in a wider range of applications. Let's take a random polynomial, like $x^3 - x^2 +2$. Our current code has no support for using a different function like this. Let's start by translating it into code:\\r\\n\\r\\n    ::python\\r\\n    def h(x): return (x**3 - x**2 + 2)\\r\\n\\r\\nNext, I'm going to create another function to wrap around our current `F(x)` function called `integrate()`, change the name of `F(x)` to `findArea()`, and update the parameters of `findArea()`:\\r\\n\\r\\n    def integrate(f, a):\\r\\n        def findArea(b, rectangles=1000):\\r\\n            delta_x = float((b-a)/rectangles)\\r\\n            area = 0\\r\\n            for n in range(1, rectangles+1):\\r\\n                area += float(delta_x) * f(delta_x*n + 1)\\r\\n            return area\\r\\n        return findArea\\r\\n\\r\\nNow, let's try computing the area under `h(x)` from 1 to 3:\\r\\n\\r\\n    ::python\\r\\n    >>> F = integrate(h, 1)\\r\\n    >>> F(3)\\r\\n    15.35134\\r\\n\\r\\nThe actual area is $\\\\frac{46}{3}$, or $15.\\\\bar{3}$. Remember, this approximation is with 1000 rectangles; if more accuracy is required, the `rectangles` parameter can be specified to a non-default value.\\r\\n\\r\\nYou might have noticed that I changed the location of the  integral limits to be parameters on `integrate()`. This is mostly for usability. I want the function and lower limit of integration to be defined with the integral, and the higher limit to be defined by `F(x)`. This way, the code and the math are somewhat interchangeable.\\r\\n\\r\\n## Trigonometry Proofs\\r\\n\\r\\nSo far, we've only tested our code on simple polynomial functions. I would like to accomplish two things in this section:\\r\\n\\r\\n1. Stress test our code on trigonometric functions, and fix it if it breaks\\r\\n2. Use our improved code to prove some trigonometric integrals\\r\\n\\r\\n#### Testing the code\\r\\n\\r\\nIf it ain't broke, don't fix it. Before we try to fix anything about our code, let's see if it works as-is. I can't really think of a reason why it *shouldn't*.\\r\\n\\r\\n    ::python\\r\\n    import math\\r\\n    >>> def g(x): return math.sin(x)\\r\\n    >>> F = integrate(g, 1)\\r\\n    >>> F(3)\\r\\n    1.5295939413935349\\r\\n\\r\\nOkay, so far this answer seems to make sense. Let's see what the actual answer is.\\r\\n\\r\\nWe proved [last time][2] that the first fundamental theorem of calculus is actually true. This means we can make use of it, and its corollaries, to mathematically find the area under $\\\\sin{x}$ from 1 to 3.\\r\\n$$\\r\\n\\\\int_1^3 \\\\sin{x}\\\\, \\\\mathrm{d}x = -\\\\cos{x} \\\\Big|_1^3 = -\\\\cos{3} + \\\\cos{1} = 1.530294802...\\r\\n$$\\r\\n\\r\\nThat seems about right. Wolfram Alpha's approximation is $\\\\approx 1.5303$. We haven't really tried anything terribly complicated with the code yet, but it seems to hold its own with trig (so far). Now you might have noticed that in my math above, I make use of the fact that the anti-derivative of $\\\\sin{x} = \\\\cos{x}$. We know that because if you take a $-\\\\cos{x}$ graph (which is just a flipped $\\\\cos{x}$ graph):\\r\\n\\r\\nTODO: insert -cosx graph\\r\\n\\r\\nthen the slope at each point is equal to the $y$ value of $\\\\sin{x}$ at the same point. Meaning, if you took the derivative of $-\\\\cos{x}$, it would be $\\\\sin{x}$. Since an integral is the **anti-derivative**, we can work in reverse and use $-\\\\cos{x}$ as the integral.\\r\\n\\r\\n### I don't believe you\\r\\n\\r\\nDon't take my word for it -- see for yourself. How can we leverage our existing codebase to prove that $\\\\int \\\\sin{x}\\\\, \\\\mathrm{d}x = -\\\\cos{x}$? Well I just said that **the derivative of $-\\\\cos{x}$ would be $\\\\sin{x}$**, so let's start there. We already used the definition of a derivative last time, so let's adapt the code to work for our current purposes.\\r\\n\\r\\n    ::python\\r\\n    def l(x): return -math.cos(x)\\r\\n\\r\\n    >>> dl = derivative(l)\\r\\n    >>> dl(1)\\r\\n    0.8414709848914015\\r\\n    >>> g(1)\\r\\n    0.8414709848078965\\r\\n\\r\\nThe first 10 decimals are the same. I was going to take this further and calculate percent deviation, but then, out of curiosity, I decided to plot some test points using matplotlib. Here's what I got:\\r\\n\\r\\n![d/dx[-cosx] and sinx][3]\\r\\n\\r\\n\\r\\nYou're probably thinking \\\"hey, that's only one graph!\\\" Actually, no; it's a plot of `dl(n)` and `g(n)` on the same graph. And in case you don't believe me, here's both of them side by side:\\r\\n\\r\\n![d/dx[-cosx] Vs. sinx][4]\\r\\n\\r\\n### Integrating in Three Dimensions\\r\\n\\r\\nNow that I've completed all of objectives outlined in the previous section, it's time to move on to the big event. We will use our existing code to\\r\\n\\r\\n[1]: /blog/proving-the-first-fundamental-theorem-of-calculus-with-python/\\r\\n[2]: /blog/proving-the-first-fundamental-theorem-of-calculus-with-python/\\r\\n[3]: /static/media/uploads/-cosx-sinx.png\\r\\n[4]: /static/media/uploads/side-by-side.png\\r\\n  \",\r\n        \"rating_sum\": 0,\r\n        \"rating_count\": 0,\r\n        \"categories\": [],\r\n        \"publish_date\": \"2015-02-28T19:42:17Z\",\r\n        \"status\": 1,\r\n        \"updated\": \"2015-02-28T19:52:01.191Z\",\r\n        \"description\": \"Area Under A Curve\\nI recently wrote an article about finding the area under $y=x^2$. I had a lot of interesting insights from that project, and it got me thinking about some other things we could do with the code. If you haven't read the article, you can get it here. I was thinking about ways to improve my code and expand its use, so that it could be used in a wider range of applications. Let's take a random polynomial, like $x^3 - x^2 +2$. Our current code has no support for using a different function like this. Let's start by translating it into code:\",\r\n        \"rating_average\": 0.0,\r\n        \"expiry_date\": null,\r\n        \"user\": 1,\r\n        \"slug\": \"area-under-a-curve-in-three-dimensions\",\r\n        \"gen_description\": true,\r\n        \"allow_comments\": true,\r\n        \"created\": \"2015-02-28T19:46:04.470Z\",\r\n        \"_meta_title\": \"\",\r\n        \"comments_count\": 0\r\n    },\r\n    \"model\": \"blog.blogpost\",\r\n    \"pk\": 5\r\n},\r\n{\r\n    \"fields\": {\r\n        \"related_posts\": [],\r\n        \"short_url\": \"http://averylaird.com/blog/tuts-your-pooh-bah-generating-random-buzzfeed-article-titles-with-python/\",\r\n        \"site\": 1,\r\n        \"keywords_string\": \"\",\r\n        \"in_sitemap\": true,\r\n        \"featured_image\": \"uploads/blog/photo-1429091967365-492aaa5accfe.jpg\",\r\n        \"title\": \"Tut your Pooh-Bah: generating random buzzfeed article titles with Python\",\r\n        \"use_dark_background\": false,\r\n        \"content\": \"I conclude my blog hiatus with a (kind-of) silly post. As I'm sure most of you have noticed, the internet is full of ads and articles that have titles with a certain structure. For example:   \\r\\n\\r\\n* 17 Celebrity Instagrams You Need To See This Week    \\r\\n* How To Get Organized: 2 Solutions From Philosophy And Kindergarten   \\r\\n* How The Most Powerful People Get Things Done: 4 Tips From A White House Staffer.\\r\\n\\r\\nAnd those were just from a 2 minute Google search. The web is full of them! And it seemed to me that they all followed a similar format, one that might easily be quantified and automated. Thus began my journey to generate random BuzzFeed-style titles!\\r\\n\\r\\n\\r\\nLet the hilarity ensue.\\r\\n\\r\\n\\r\\n# Propound Their Chara: Breaking down the structure\\r\\n\\r\\nBefore we can begin programatically generating the titles, we first have to identify which words should go where. Since all the titles are *similar*, but not strictly the same, we should choose a **compromise** between the numerous variants out there. I decided to go with the following structure. **Note** -- words to be generated or selected randomly are enclosed by `<>`:\\r\\n\\r\\n    <verb><possessive determiner><noun>: <number><adjective><tips,tricks,etc> to <verb><possessive determiner><noun>\\r\\n\\r\\nAt first glance, one of the things I noticed was that the first three words and the last three words are of the exact same *structure*, but are not the same word. To give you a better idea of the format I'm going for, I'll give you an example of a title in this format:  \\r\\n\\r\\n* Organize your calendar: 17 great tips to increase your productivity\\r\\n\\r\\nThe verbs won't be too tricky: most verbs in the present tense should work fine. However, the \\\"possessive determiner\\\" might be difficult, because even within the domain of possessive determiners there are few words which realistically make sense in that sentence. That's why I simply chose three off the top of my head: your, our, and their.   \\r\\n\\r\\nSimilar to the verbs, any noun in the present tense should fit in a sentence of that structure. The same goes for the adjectives. And finally, numbers can easily be generated randomly (pseudo-randomly).\\r\\n\\r\\n# Flex our Hygrostats: Writing the Code\\r\\n\\r\\nI didn't want to use any dedicated libraries for this, mainly because I think using one like **nltk** would be overkill, but also because I'm not knowledgeable enough about using it to even look like I know what I'm doing.\\r\\n\\r\\nFor this script, I used a plaintext list of verbs, nouns and adjectives placed in the same directory as the code. You can use any list you want, but here are the ones I used: [verbs.txt][1], [nouns.txt][2], and [adjectives.txt][3].\\r\\n\\r\\nThe first thing we should do is establish a method of reading lines from a file at random. I thought there was no pretty way to do it until I came across [this][4] on stackoverflow. It's beautiful! One thing that may trip people up, however, is confusing the type of parameter to pass. `random_line()` takes a file object. So first, we make use of this awesome code sample:\\r\\n\\r\\n    ::python\\r\\n    import random\\r\\n    random.seed()\\r\\n\\r\\n    def random_line(afile):\\r\\n        line = next(afile)\\r\\n        for num, aline in enumerate(afile):\\r\\n            if random.randrange(num + 2): continue\\r\\n            line = aline\\r\\n        return line\\r\\n\\r\\nWe need a total of 2 verbs, so to keep everything organized, let's get those first and at the same time:\\r\\n\\r\\n    ::python\\r\\n    verbs = [verb.rstrip() for verb in [random_line(open('verbs.txt', 'r')) for x in range(2)]]\\r\\n\\r\\nNext, let's make a list with the possessive determiners:\\r\\n\\r\\n    ::python\\r\\n    pd = ['your','our','their']\\r\\n\\r\\nAnd generate the nouns the same way as the verbs:\\r\\n\\r\\n    ::python\\r\\n    nouns = [noun.rstrip() for noun in [random_line(open('nouns.txt','r')) for x in range(2)]]\\r\\n\\r\\nWe only need one adjective, so the line is a bit simpler:\\r\\n\\r\\n    ::python\\r\\n    adjs = random_line(open('adjectives.txt','r')).rstrip()\\r\\n\\r\\nNext we'll need what I call the \\\"filler text\\\":\\r\\n\\r\\n    ::python\\r\\n    ft = ['tips', 'tricks', 'suggestions', 'choices']\\r\\n\\r\\nLastly, the mother of all print statements:\\r\\n\\r\\n    ::python\\r\\n    print verbs[0] + \\\" \\\" + pd[random.randint(0, 2)] + \\\" \\\" + nouns[0] + \\\": \\\" + str(random.randint(0,15000)) + \\\" \\\" + adjs + \\\" \\\" + ft[random.randint(0,3)] + \\\" to \\\" + verbs[1] + \\\" \\\" + pd[random.randint(0,2)] + \\\" \\\" + nouns[1]\\r\\n\\r\\nHere's the whole script, for copying/viewing ease:\\r\\n\\r\\n    ::python\\r\\n    # main.py\\r\\n\\r\\n    import random\\r\\n    random.seed()\\r\\n\\r\\n    def random_line(afile):\\r\\n        line = next(afile)\\r\\n        for num, aline in enumerate(afile):\\r\\n            if random.randrange(num + 2): continue\\r\\n            line = aline    \\r\\n        return line\\r\\n\\r\\n\\r\\n    verbs = [verb.rstrip() for verb in [random_line(open('verbs.txt', 'r')) for x in range(2)]]\\r\\n\\r\\n    pd = ['your','our','their']\\r\\n\\r\\n    nouns = [noun.rstrip() for noun in [random_line(open('nouns.txt','r')) for x in range(2)]]\\r\\n\\r\\n    adjs = random_line(open('adjectives.txt','r')).rstrip()\\r\\n    ft = ['tips', 'tricks', 'suggestions', 'choices']\\r\\n\\r\\n\\r\\n    print verbs[0] + \\\" \\\" + pd[random.randint(0, 2)] + \\\" \\\" + nouns[0] + \\\": \\\" + str(random.randint(0,15000)) + \\\" \\\" + adjs + \\\" \\\" + ft[random.randint(0,3)] + \\\" to \\\" + verbs[1] + \\\" \\\" + pd[random.randint(0,2)] + \\\" \\\" + nouns[1]\\r\\n\\r\\nWell, it's not winning any PEP awards, but I got to use some fancy list comprehensions. Let's take it for a spin:\\r\\n\\r\\n    $ python main.py\\r\\n    titter your gorgons: 8358 longhand tips to polarize your grits\\r\\n\\r\\nHere are some other titles that were generated during testing:  \\r\\n\\r\\n* flex our hygrostats: 15 Lemnian tricks to isolate your Mariolater\\r\\n* bemusing their recusants: 0.550137098499 gory choices to deep-freeze their functionary\\r\\n* propound their chara: 4073 ecstatic tricks to paik their expiation\\r\\n* hade our linguine: 13337 teind tricks to obturate your frequentation \\r\\n\\r\\nSo it works! However, not perfectly. There are two main issues:\\r\\n\\r\\n### Present tense verbs\\r\\n\\r\\nBecause we just use one big list o' verbs, some of them are in the wrong tense. I opted to leave this out of the code, for you to tweak after if you need to. This is where using a library like **nltk** can come in handy, or finding a list with verbs of only the proper tense.\\r\\n\\r\\n### Any combination is possible\\r\\n\\r\\nThis is great, except that there are a lot of words in the English language, some of them ranging from funny to really, really offensive. I know from playing around with the script a bit that if you're in doubt about what a word means, look it up. \\r\\n\\r\\n----\\r\\n\\r\\n# Improvements\\r\\n\\r\\nHow can we make this better? I've got a couple ideas. \\r\\n\\r\\n### Generalize\\r\\n\\r\\nLet's say I want to create a sentence with any structure, using random words. The script could be modified to take an argument, similar to the pseudo-code used earlier in the article, and construct a sentence from a user-defined structure. \\r\\n\\r\\n### Contextualize\\r\\n\\r\\nRight now, some sentences need a bit of tweaking. For example, they might be in the wrong tense. Using a natural language library could be the solution, but that would also add a level of complexity.\\r\\n\\r\\n# Conclusion\\r\\n\\r\\nHave fun creating your very own random titles. I'm interested to see what ones you guys might generate! If you notice any errors or typos, please send me an email at laird.avery@gmail.com or comment below.\\r\\n\\r\\n\\r\\n  [1]: http://www.averylaird.com/static/media/uploads/blog/verbs.txt\\r\\n  [2]: http://www.averylaird.com/static/media/uploads/blog/nouns.txt\\r\\n  [3]: http://www.averylaird.com/static/media/uploads/blog/adjectives.txt\\r\\n  [4]: http://stackoverflow.com/questions/3540288/how-do-i-read-a-random-line-from-one-file-in-python\",\r\n        \"rating_sum\": 0,\r\n        \"rating_count\": 0,\r\n        \"categories\": [],\r\n        \"publish_date\": \"2015-06-01T02:19:24Z\",\r\n        \"status\": 2,\r\n        \"updated\": \"2015-06-01T03:06:23.655Z\",\r\n        \"description\": \"I conclude my blog hiatus with a (kind-of) silly post. As I'm sure most of you have noticed, the internet is full of ads and articles that have titles with a certain structure. For example:   \",\r\n        \"rating_average\": 0.0,\r\n        \"expiry_date\": null,\r\n        \"user\": 2,\r\n        \"slug\": \"tuts-your-pooh-bah-generating-random-buzzfeed-article-titles-with-python\",\r\n        \"gen_description\": true,\r\n        \"allow_comments\": true,\r\n        \"created\": \"2015-05-31T23:25:55.820Z\",\r\n        \"_meta_title\": \"\",\r\n        \"comments_count\": 0\r\n    },\r\n    \"model\": \"blog.blogpost\",\r\n    \"pk\": 6\r\n},\r\n{\r\n    \"fields\": {\r\n        \"related_posts\": [\r\n            4\r\n        ],\r\n        \"short_url\": \"http://averylaird.com/blog/describing-elliptical-orbits-programmatically/\",\r\n        \"site\": 1,\r\n        \"keywords_string\": \"\",\r\n        \"in_sitemap\": true,\r\n        \"featured_image\": \"uploads/blog/eva-spaceman-desk-1024.jpg\",\r\n        \"title\": \"Describing Elliptical Orbits Programmatically \",\r\n        \"use_dark_background\": false,\r\n        \"content\": \"Like most space nerds, I play [Kerbal Space Program][1]. I also read *[The Martian][2]* a couple months ago; it was a terrific book, and I highly recommend it. One of my favourite aspects of the book, which is also its claim to fame, is its very impressive intention to be as scientifically accurate as possible. I've always been interested in how KSP simulates orbits, but *The Martian* also got me thinking about how actual orbital maneuvers are planned, and the math involved. That's why I decided to see if I could use math, and Python, to describe the orbits of Earth and Mars. \\r\\n\\r\\n## The Math\\r\\n\\r\\n[This wikipedia article][3] very helpfully breaks down the math into four distinct steps:     \\r\\n\\r\\n1. Compute the **mean anomaly**: $M = nt, nP = 2\\\\pi$        \\r\\n    $$M = \\\\frac{2\\\\pi t}{P}$$    \\r\\n    Where $n$ is the *mean motion*, $M$ is the *mean anomaly*, and $t$ is the time since [perihelion][4]. It's interesting to note that in the consolidated formula, we get the relationship $\\\\frac{t}{P}$. Therefore, since $2\\\\pi$ is constant, the term which defines $M$ is simply the ratio between time since perihelion and the orbital period. This means that **any** unit of time can be used, as long as it is used for **both parameters**.\\r\\n2. Compute the **eccentric anomaly** $E$ by solving [Kepler's equation][5]:    \\r\\n    $$M = E - \\\\varepsilon\\\\sin{E} $$    \\r\\n    Where $\\\\varepsilon$ is the [eccentricity][6] of the orbit\\r\\n\\r\\n3. Compute the **true anomaly** $\\\\theta$ by the equation:    \\r\\n    $$(1 - \\\\varepsilon)\\\\tan^2{\\\\frac{\\\\theta}{2}} = (1 + \\\\varepsilon)\\\\tan^2{\\\\frac{E}{2}}$$\\r\\n\\r\\n4. Compute the **heliocentric distance**:    \\r\\n    $$r = a(1 - \\\\varepsilon \\\\cos{E})$$\\r\\n\\r\\n    Where $a$ is the [semi-major axis][7].\\r\\n\\r\\nNext, we'll translate each step in to code.\\r\\n\\r\\n**NOTE:** You can find all the code in one place at [the end of this article](#code)\\r\\n\\r\\n###Step One\\r\\nFirst, you'll need to import the `math` module, and install `matplotlib`. I recommend using a package manager to install `matplotlib`, eg `sudo apt-get install python-matplotlib`. As the first thing in your file, you should end up with:    \\r\\n    \\r\\n    ::python\\r\\n    import math\\r\\n    from matplotlib import pyplot as plt    \\r\\n\\r\\n\\r\\nFor step one, we need to **compute the mean anomaly**. We need time since perihelion and the orbital period, so we'll make those parameters:    \\r\\n\\r\\n    ::python\\r\\n    def step_one(t, p):\\r\\n        \\\"\\\"\\\"\\r\\n        M = mean anomaly\\r\\n        M = 2pi * t\\r\\n            -------\\r\\n               P\\r\\n        \\\"\\\"\\\"\\r\\n        return (2 * math.pi * t) / p\\r\\n\\r\\n###Step Two\\r\\nIn step two, we're solving for the **eccentric anomaly**, and we need the *mean anomaly* and *eccentricity* to do it.    \\r\\n\\r\\nSince Kepler's equation is [transcendental][8], and cannot be solved algebraically, the solution has to be found numerically.     \\r\\n\\r\\nWe've got two lines, one horizontal, one slanted with slope = 1, and the point where they intersect is our solution. Or, you could move the $M$ over to get $M - E + \\\\varepsilon\\\\sin{E} = 0$ and say the root is your solution. I choose the former. It looks something like this:    \\r\\n \\r\\n<img src=\\\"/static/media/uploads/kepler%27s_equation_graph.png\\\" width=60%>\\r\\n\\r\\nWe know that $M$, a constant value, will always be greater than $E - \\\\varepsilon\\\\sin{E}$ when $E = 0$. In fact, the right side of the equation is basically a slanted $\\\\sin{x}$ graph. You could also think of it as a $y = x$ graph being sinusoidally translated up and down, where the amplitude of translation is the eccentricity of the orbit.    \\r\\n\\r\\nKnowing that the right side of the equation will always start out as being less than the left, to find the intersection point we can just increase values of $E$ (starting with $E = 0$) until the right side is equal to the left. **However**: we'll be computing thousands of positions, and we want to be able to find the solution very quickly, but also with lots of precision. That's why our algorithm should be as follows:    \\r\\n\\r\\n**Initial Conditions:** $E = 0$    \\r\\n\\r\\n* Is right side < left side?\\r\\n    - Yes: increment $E$ by 1\\r\\n    - No: Is right side > left side?\\r\\n        - Yes: decrement $E$ by 0.00001\\r\\n        - No: **stop**\\r\\n\\r\\nThis method is fast, but can also be arbitrarily precise by adding as many decimal points to the decrement step as need. \\r\\n     \\r\\n    ::python\\r\\n    def step_two(m, e):\\r\\n        \\\"\\\"\\\"\\r\\n        M = mean anomaly\\r\\n        E = eccentric anomaly\\r\\n        e = eccentricity\\r\\n\\r\\n        M = E - esinE\\r\\n        \\\"\\\"\\\"\\r\\n        def M(E): return E - (e * math.sin(E))\\r\\n        E = 0\\r\\n        while m > M(E):\\r\\n            E += 1\\r\\n        while M(E) > m:\\r\\n            E -= 0.00001\\r\\n        return E\\r\\n\\r\\n###Step Three\\r\\nThis is, by far, the hardest step to implement. It's easy to get tripped up because it involves a $\\\\tan$ equation which has **two solutions** in a given cycle. This step will require a bit of high school trigonometry.    \\r\\n\\r\\nFirst of all, the right side of the equation, $(1 + \\\\varepsilon)\\\\tan^2{\\\\frac{E}{2}}$, is a number -- all of the variables are known -- so let's forget about it for now.    \\r\\n\\r\\nNormally, $\\\\tan$ has a period of $\\\\pi$. When you square it, the period doesn't change, but when you divide the variable $\\\\theta$ by 2, $\\\\tan^2{\\\\frac{\\\\theta}{2}}$, then the period becomes $2\\\\pi$:\\r\\n\\r\\n<img src=\\\"/static/media/uploads/tan.png\\\" width=60%>\\r\\n\\r\\nNow the right side of our equation, which is a number (not a variable), will be a horizontal line which intersects with the $\\\\tan^2{\\\\frac{\\\\theta}{2}}$ **twice**, like this:\\r\\n\\r\\n<img src=\\\"/static/media/uploads/tan_and_linear.png\\\" width = 60%>\\r\\n\\r\\nNow the tricky part is that we need **both** of those solutions. One of the solutions is for when $0 \\\\le t \\\\le \\\\frac{P}{2}$, and the other is for when $t \\\\gt \\\\frac{P}{2}$. In other words, without the second solution, you won't be able to calculate true anomalies for times greater than half the orbital period. My solution is this:\\r\\n\\r\\n    ::python\\r\\n        def step_three(e, E):\\r\\n        \\\"\\\"\\\"\\r\\n        (1 - e)tan^2(theta/2) = (1 + e)tan^2(E/2)\\r\\n        e = eccentricity\\r\\n        theta = true anomaly\\r\\n        E = eccentric anomaly\\r\\n        \\\"\\\"\\\"\\r\\n        def l(theta): return (1-e)*(math.tan(theta/2))**2\\r\\n        r = (1+e)*(math.tan(E/2))**2\\r\\n        theta = 0\\r\\n        while l(theta) < r:\\r\\n            theta += 0.1\\r\\n        while r < l(theta):\\r\\n            theta -= 0.00001\\r\\n        return [theta, 2*(math.pi - theta) + theta]\\r\\n\\r\\nAs you can see, this step is very similar in principle to step two, with some key differences. First, I increment by 0.1 and not 1. This is because the angles are very small to begin with, and so incrementing by 0.1 many times is much faster than decrementing by 0.00001 many times. Second, this step returns a list and not a number. The list contains both solutions. In order to get the second solution, a bit of  reasoning is need.     \\r\\n\\r\\nFirst, the $\\\\tan^2{\\\\frac{\\\\theta}{2}}$ graph is symmetrical in its cycle, meaning the values after $\\\\pi$ can be described as a reflection of the previous values ($0 \\\\lt x \\\\lt \\\\pi$)  over a line $x = \\\\pi$. This means that the distance from the first solution $\\\\theta_1$ to $\\\\pi$, which is $\\\\pi - \\\\theta_1$, is equal to the distance from the second solution $\\\\theta_2$ to $\\\\pi$. Therefore, the distance **between** solutions is $2(\\\\pi - \\\\theta_1)$. The value of $\\\\theta_2$ can then be found by the equation:    \\r\\n$$\\\\theta_2 = 2(\\\\pi - \\\\theta_1) + \\\\theta_1$$\\r\\n\\r\\nThe solution to use will be determined later, since $t$ and $P$ are required.\\r\\n\\r\\nOkay, we made it through the toughest part! It's all smooth sailing from here.\\r\\n\\r\\n###Step Four\\r\\n\\r\\nThis is where we calculate the heliocentric distance, or the planet's distance from the sun. It is given by the equation $r = a(1 - \\\\varepsilon\\\\cos{E})$. We will need the semi-major axis, eccentricity, and eccentric anomaly as parameters:    \\r\\n\\r\\n    ::python\\r\\n    def step_four(a, e, E):\\r\\n        \\\"\\\"\\\"\\r\\n        a = semi-major axis\\r\\n        e = eccentricity\\r\\n        E = eccentric anomaly\\r\\n\\r\\n        r = a(1 - ecosE)\\r\\n        \\\"\\\"\\\"\\r\\n        return a * (1 - (e * math.cos(E)))    \\r\\n \\r\\n\\r\\n###Tying it all together\\r\\n\\r\\nAt this point, you have all the tools you need to predict the position of a planetary body as a function of time. However, I would recommend creating one last function that handles the order of calculations and determines which true anomaly solution to use. I just made a simple, barebones one:    \\r\\n\\r\\n    ::python\\r\\n    def calculate(e, t, p, a):\\r\\n        M = step_one(t, p)\\r\\n        E = step_two(M, e)\\r\\n        if list(math.modf(float(t) / p))[0] > 0.5:\\r\\n            theta = step_three(e, E)[1]\\r\\n        if list(math.modf(float(t) / p))[0] < 0.5:\\r\\n            theta = step_three(e, E)[0]\\r\\n        r = step_four(a, e, E)\\r\\n        return [theta, r] \\r\\n\\r\\nLastly, I like to plot things, and I want to plot orbits. At the beginning of this article I said I wanted to predict the orbits of Earth *and* Mars, so here's some example code to accomplish this:\\r\\n\\r\\n    ::python\\r\\n    e_theta, e_r = [], [] \\r\\n    m_theta, m_r = [], []  \\r\\n    for x in range(0, 365):\\r\\n        e_coords = calculate(0.0167, x, 365, 1.496E8)\\r\\n        e_theta.append(e_coords[0])\\r\\n        e_r.append(e_coords[1])\\r\\n        m_coords = calculate(0.0935, x, 687, 2.2792E8)\\r\\n        m_theta.append(m_coords[0])\\r\\n        m_r.append(m_coords[1]) \\r\\n    plt.polar(e_theta, e_r)\\r\\n    plt.polar(m_theta, m_r, 'r')\\r\\n    plt.show()\\r\\n\\r\\nThis gives me a pretty graph that looks like this:\\r\\n\\r\\n<img src=\\\"/static/media/uploads/figure_1.png\\\" width=60%>\\r\\n\\r\\n##Conclusion\\r\\n\\r\\nWith this code, I see many interesting avenues of research. I can plot more planets, graph their velocity, relative distances, relative angles, etc. Eventually I plan to refine this code for actual calendar dates, and use it to determine launch dates and windows.    \\r\\n\\r\\n###Improvements\\r\\n\\r\\nSome possible improvements could be made on the true anomaly function. Since orbits are quite often plotted one way, and sequentially, it could be optimized for this purpose by accepting the previously calculated angle as a starting point for calculating the next, instead of starting from 0 for all angles. This would be easily done with a parameter which defaults to 0.    \\r\\n\\r\\nThe orbits could also be more precise by taking the gravitational influence of other bodies in to account. Additionally, when calculating relative distances more precision could be gained by taking into account the third dimension. This would require additional orbital elements, namely the orbital inclination.\\r\\n\\r\\n###The whole `!#`<a name=\\\"code\\\"></a>\\r\\nHere's all the code, for those who are lazy:    \\r\\n\\r\\n    ::python\\r\\n    import math\\r\\n    from matplotlib import pyplot as plt\\r\\n  \\r\\n    def step_one(t, p):\\r\\n        \\\"\\\"\\\"\\r\\n        M = mean anomaly\\r\\n        M = 2pi * t\\r\\n            -------\\r\\n               P\\r\\n        \\\"\\\"\\\"\\r\\n        return (2 * math.pi * t) / p\\r\\n\\r\\n    def step_two(m, e):\\r\\n        \\\"\\\"\\\"\\r\\n        M = mean anomaly\\r\\n        E = eccentric anomaly\\r\\n        e = eccentricity\\r\\n\\r\\n        M = E - esinE\\r\\n        \\\"\\\"\\\"\\r\\n        def M(E): return E - (e * math.sin(E))\\r\\n        E = 0\\r\\n        while m > M(E):\\r\\n            E += 1\\r\\n        while M(E) > m:\\r\\n            E -= 0.00001\\r\\n        return E\\r\\n  \\r\\n    def step_three(e, E):\\r\\n        \\\"\\\"\\\"\\r\\n        (1 - e)tan^2(theta/2) = (1 + e)tan^2(E/2)\\r\\n        e = eccentricity\\r\\n        theta = true anomaly\\r\\n        E = eccentric anomaly\\r\\n        \\\"\\\"\\\"\\r\\n        def l(theta): return (1-e)*(math.tan(theta/2))**2\\r\\n        r = (1+e)*(math.tan(E/2))**2\\r\\n        theta = 0\\r\\n        while l(theta) < r:\\r\\n            theta += 0.1\\r\\n        while r < l(theta):\\r\\n            theta -= 0.00001\\r\\n        return [theta, 2*(math.pi - theta) + theta]\\r\\n\\r\\n    def step_four(a, e, E):\\r\\n        \\\"\\\"\\\"\\r\\n        a = semi-major axis\\r\\n        e = eccentricity\\r\\n        E = eccentric anomaly\\r\\n\\r\\n        r = a(1 - ecosE)\\r\\n        \\\"\\\"\\\"\\r\\n        return a * (1 - (e * math.cos(E)))\\r\\n\\r\\n    def calculate(e, t, p, a):\\r\\n        M = step_one(t, p)\\r\\n        E = step_two(M, e)\\r\\n        if list(math.modf(float(t) / p))[0] > 0.5:\\r\\n            theta = step_three(e, E)[1]\\r\\n        if list(math.modf(float(t) / p))[0] < 0.5:\\r\\n            theta = step_three(e, E)[0]\\r\\n        r = step_four(a, e, E)\\r\\n        return [theta, r]\\r\\n     \\r\\n    e_theta, e_r = [], []\\r\\n    m_theta, m_r = [], []\\r\\n    for x in range(0, 365):\\r\\n        e_coords = calculate(0.0167, x, 365, 1.496E8)\\r\\n        e_theta.append(e_coords[0])\\r\\n        e_r.append(e_coords[1])\\r\\n        m_coords = calculate(0.0935, x, 687, 2.2792E8)\\r\\n        m_theta.append(m_coords[0])\\r\\n        m_r.append(m_coords[1])\\r\\n    plt.polar(e_theta, e_r)\\r\\n    plt.polar(m_theta, m_r, 'r')\\r\\n    plt.show()\\r\\n\\r\\n##Final Thoughts\\r\\n\\r\\nIf you made it all the way to the end, I'm very impressed. Thanks for reading!     \\r\\n\\r\\nI try to be as accurate as possible, but if you see any mistakes or have any questions, comment below or feel free to email me at laird.avery@gmail.com.\\r\\n \\r\\n\\r\\n\\r\\n  [1]: https://kerbalspaceprogram.com/en/\\r\\n  [2]: https://en.wikipedia.org/wiki/The_Martian_%28Weir_novel%29\\r\\n  [3]: https://en.wikipedia.org/wiki/Kepler%27s_laws_of_planetary_motion#Position_as_a_function_of_time\\r\\n  [4]: https://en.wikipedia.org/wiki/Perihelion_and_aphelion\\r\\n  [5]: https://en.wikipedia.org/wiki/Kepler%27s_equation\\r\\n  [6]: https://en.wikipedia.org/wiki/Orbital_eccentricity\\r\\n  [7]: https://en.wikipedia.org/wiki/Semi-major_axis\\r\\n  [8]: https://en.wikipedia.org/wiki/Transcendental_equation\",\r\n        \"rating_sum\": 0,\r\n        \"rating_count\": 0,\r\n        \"categories\": [\r\n            2\r\n        ],\r\n        \"publish_date\": \"2015-06-19T19:37:03Z\",\r\n        \"status\": 2,\r\n        \"updated\": \"2015-06-22T03:22:24.397Z\",\r\n        \"description\": \"Like most space nerds, I play Kerbal Space Program. I also read The Martian a couple months ago; it was a terrific book, and I highly recommend it. One of my favourite aspects of the book, which is also its claim to fame, is its very impressive intention to be as scientifically accurate as possible. I've always been interested in how KSP simulates orbits, but The Martian also got me thinking about how actual orbital maneuvers are planned, and the math involved. That's why I decided to see if I could use math, and Python, to describe the orbits of Earth and Mars. \",\r\n        \"rating_average\": 0.0,\r\n        \"expiry_date\": null,\r\n        \"user\": 2,\r\n        \"slug\": \"describing-elliptical-orbits-programmatically\",\r\n        \"gen_description\": true,\r\n        \"allow_comments\": true,\r\n        \"created\": \"2015-06-19T16:10:05.820Z\",\r\n        \"_meta_title\": \"\",\r\n        \"comments_count\": 0\r\n    },\r\n    \"model\": \"blog.blogpost\",\r\n    \"pk\": 7\r\n},\r\n{\r\n    \"fields\": {\r\n        \"related_posts\": [],\r\n        \"short_url\": \"unset\",\r\n        \"site\": 1,\r\n        \"keywords_string\": \"\",\r\n        \"in_sitemap\": true,\r\n        \"featured_image\": \"uploads/blog/photo-1427097829427-56a905bf7004.jpg\",\r\n        \"title\": \"The Hat Problem\",\r\n        \"use_dark_background\": true,\r\n        \"content\": \"<p>There's a famous math problem of which I recently became aware, commonly called \\\"The Hat Check Problem\\\" (or some variant).</p>\\r\\n<p>The problem usually goes something like this:</p>\\r\\n<p style=\\\"padding-left: 30px;\\\">You are checking hats at a party, and neglect to mark the hats for idenification later. As more and more people arrive, you begin to lose track of who owns which hat. When the party ends and people begin to leave, you hand out hats at random, and hope for a correct match.</p>\\r\\n<p>There are a lot of predictions I made about what the probability (as a function of hats, or people) would look like -- all of them were wrong. The correct answer is awesomely inobvious.</p>\\r\\n<p>It seems quite reasonable to say that as the number of hats -- $n$ -- increases, the probability of an&nbsp;<strong>incorrect</strong> match -- $P$ -- would increase as well. At first, I thought the end behaviour of $P(n)$ would approach infinity, or $\\\\lim\\\\limits_{n\\\\to \\\\infty}P(n) = \\\\infty$. Wrong!</p>\\r\\n<p>Then, I thought that maybe $P$ would approach some value to form an asymptote. This is a bit more accurate. But what value does $P$ approach?&nbsp;</p>\\r\\n<p>Without including a huge explanation about <a href=\\\"https://en.wikipedia.org/wiki/Derangement\\\">derangement</a>, I'll cheat a little and use a general formula. For $n$ hats, the probability $P$ of an&nbsp;<strong>incorrect</strong> match is defined as: $$P(n) = 1 - \\\\frac{1}{1!} + \\\\frac{1}{2!} - \\\\frac{1}{3!} + \\\\cdots + \\\\frac{(-1)^n}{n!}$$</p>\\r\\n<p>One interesting thing to notice about this equation is the $n$th power on the numerator. If you remember your highschool math, you'll notice that for all terms where $n$ is <em>odd</em>, that term will be&nbsp;<em>negative</em>, and vice versa. This is because a negative multiplied by a negative is a positive, but a positive multiplied by a negative is negative. To illustrate: $$(-1)^2 = (-1) \\\\cdot (-1) = 1$$ $$(-1)^1 = (-1)$$&nbsp;&nbsp;</p>\\r\\n<p>Therefore, the sign of each term switches.&nbsp;</p>\\r\\n<p>I want to know what happens as $n\\\\to \\\\infty$, but at first glance, I can't figure out a way to solve a limit with a factorial in it: $$\\\\lim_{n\\\\to \\\\infty}(1 - \\\\frac{(-1)^n}{n!})$$</p>\\r\\n<p>It's probably the easiest to solve using the <a href=\\\"https://en.wikipedia.org/wiki/Squeeze_theorem\\\">squeeze theorem</a>, but I bet I can do it in 6 lines of Python.</p>\\r\\n<p>First, let's import the math module and name our function:</p>\\r\\n<pre>#the_hat_problem.py<br />import math<br /><br />def P(n):<br />    # code here</pre>\\r\\n<p>Next, we need to translate our general equation,&nbsp;$P(n) = 1 + \\\\frac{(-1)^n}{n!}$, into Python code. First, we'll create a variable&nbsp;<code>terms</code>&nbsp;. For every hat, we will compute the term and add it to <code>terms</code>.&nbsp;Finally, we will subtract <code>terms</code> from 1.</p>\\r\\n<pre>#the_hat_problem.py<br />import math<br /><br />def P(n):<br />&nbsp; &nbsp; terms = 0<br />&nbsp; &nbsp; for x in range(1, n+1):<br />&nbsp; &nbsp; &nbsp; &nbsp; terms -= (math.pow(-1.0, x)) / math.factorial(x)<br />&nbsp; &nbsp; return 1 - terms</pre>\\r\\n<p>So, now we have a way to compute the probability of an incorrect match for $n$ hats. Let's test it out: for one hat, $P(1) = 0\\\\%$, since there is only one possible match. For two hats, $P(2) = 50\\\\%$.&nbsp;</p>\\r\\n<blockquote>It's interesting to note that for the second two whole values of $n$, $2$ and $3$, $P(n)$ is perfectly approximated by $\\\\frac{1}{n}$. For example, $P(2) = 0.5 = \\\\frac{1}{n} = 0.5$</blockquote>\\r\\n<p>Sanity check:</p>\\r\\n<pre>&gt;&gt;&gt; from the_hat_problem import P<br />&gt;&gt;&gt; P(1)<br />0.0<br />&gt;&gt;&gt; P(2)<br />0.5<br />&gt;&gt;&gt; P(3)<br />0.33333333333333337</pre>\\r\\n<p>&nbsp;So far, so good!</p>\\r\\n<h2>This one goes to eleven</h2>\\r\\n<p>Let's return to our original goal of determining the end behaviour of $P(n)$. Using a larger value of $n$:</p>\\r\\n<pre>&gt;&gt;&gt; P(50)<br />0.3678794411714422<br />&gt;&gt;&gt; P(100)<br />0.3678794411714422</pre>\\r\\n<p>That's weird... $P(50)$ and $P(100)$ are equal to at least 16 digits. It looks like the function converges on $0.3678794411714422$, but what is that numbers signifigance?</p>\\r\\n<h2>If $\\\\frac{d}{dx}i^x = i^x$, what is $i$?</h2>\\r\\n<p>Chances are you don't recognize the number $0.3678794411\\\\ldots$ at first glance. However, you might've heard of the number $e$. It just happens that&nbsp;$0.3678794411\\\\ldots$ is the inverse of $e$, or $\\\\frac{1}{e}$. At times like these, I find the quote below to be useful.</p>\\r\\n<blockquote>In mathematics you don't understand things. You just get used to them. <br />- John von Neumann</blockquote>\\r\\n<p>&nbsp;So how does $e$ relate to this equation? I really don't know, but at least we can tentatively say that: $$\\\\lim_{n\\\\to \\\\infty}(1 - \\\\frac{1}{1!} + \\\\frac{1}{2!} - \\\\frac{1}{3!} + \\\\cdots + \\\\frac{(-1)^n}{n!}) \\\\approx \\\\frac{1}{e} $$</p>\\r\\n<p>We can prove, at least to 15 digits (the last one might be rounded) that this is true.&nbsp;</p>\\r\\n<h2>What does it look like?</h2>\\r\\n<p>I'm curious to see a graph of our data, let's try it:</p>\\r\\n<pre>&gt;&gt;&gt; y = [P(x) for x in range(0, 100)]<br />&gt;&gt;&gt; plt.plot(range(0, 100), y)<br />&gt;&gt;&gt; plt.show()</pre>\\r\\n<p>I get a nice graph that looks like this:</p>\\r\\n<p><img src=\\\"/static/media/uploads/figure_1_hat.png\\\" alt=\\\"\\\" width=\\\"600\\\" height=\\\"452\\\" /></p>\\r\\n<p>It's evident that $P(n)$ settles on $e$ quite quickly, by around $n = 5$ or $6$. That's really fast! By the time you have 5 hats in the mix, you're already looking at a probability of $\\\\frac{1}{e}$ for zero matches. What about a higher resolution of $n$?</p>\\r\\n<p>&nbsp;</p>\",\r\n        \"rating_sum\": 0,\r\n        \"rating_count\": 0,\r\n        \"categories\": [\r\n            3\r\n        ],\r\n        \"publish_date\": \"2015-08-26T14:56:35Z\",\r\n        \"status\": 1,\r\n        \"updated\": \"2015-08-27T20:30:45.514Z\",\r\n        \"description\": \"There's a famous math problem of which I recently became aware, commonly called \\\"The Hat Check Problem\\\" (or some variant).\",\r\n        \"rating_average\": 0.0,\r\n        \"expiry_date\": null,\r\n        \"user\": 2,\r\n        \"slug\": \"the-hat-problem\",\r\n        \"gen_description\": true,\r\n        \"allow_comments\": true,\r\n        \"created\": \"2015-08-26T23:19:13.163Z\",\r\n        \"_meta_title\": \"\",\r\n        \"comments_count\": 0\r\n    },\r\n    \"model\": \"blog.blogpost\",\r\n    \"pk\": 9\r\n}\r\n]", 
            "site_id": 1, 
            "title": "fixtures"
        }
    }
]